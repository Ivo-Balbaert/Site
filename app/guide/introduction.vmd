---
title: Introduction
path: guide/introduction
layout: annotated
namespace: m-annotated
series-name: Vale Language Guide
series-entry: []()
series-entry: [Structs](/guide/structs)
series-entry: [References](/guide/references)
series-entry: [Interfaces](/guide/interfaces)
series-entry: [Generics](/guide/generics)
series-entry: [Patterns](/guide/patterns)
series-entry: [Regions](/guide/regions)
---

Welcome to Vale! Vale is a fast, safe, and easy programming language. This introduction will show how to write a program in Vale.

This reference assumes that you are familiar with basic programming concepts, and at least one other imperative language (like C, Java, Python, etc).

Vale is still "in alpha", which means it's a preview; you can write programs in it, but some of the features that make it easy aren't yet available.


# Hello world!

<<<<<

Put the code to the right into a file named hello.vale, and then run vale run hello.vale to see it produce the output in the gray box. [# We can also make an executable with `vale build hello.vale`, which produces an executable `hello` (or `hello.exe` on windows). We can also specify the name with the -o flag.]

/////

```Vale
fn main() {
  println("Hello world!");
}
```output
Hello world!
```

>>>>>


# Locals

<<<<<

We can make a local variable with the {=} symbol.

By default, a local is `final`, and a final local cannot be changed after it's made.

/////

```Vale
fn main() {
  x = "world!";
  println("Hello " + x);
}
```output
Hello world!
```

>>>>>

<<<<<

We can make a *varying* local with the `!` symbol, [# Vale's `x` and `x!` are like Java's `final int x` and `int x`.] and change it with the `mut` keyword.

/////

```Vale
fn main() {
  x! = "world!";
  mut x = "Antarctica!";
  println("Hello " + x);
}
```output
Hello Antarctica!
```

>>>>>


<notes/>


# Static Typing & Inference

Vale is a [statically typed](https://stackoverflow.com/questions/1517582/what-is-the-difference-between-statically-typed-and-dynamically-typed-languages) language, which means the type of every local and member is known at compile-time.


<<<<<

In this example, `a` is a `str`. We can even specify it after the local's name.

...though we usually leave it out, because Vale uses type inference to figure out the type of `x` for us.

/////

```Vale
fn main() {
  x Str = "world!";
  println("Hello " + x);
}
```output
Hello world!
```

>>>>>

<notes/>


# Functions

<<<<<

Here we have a simple function that `ret`urns the argument plus two.

/////

```Vale
fn add2(x int) int {
  ret x + 2;
}
fn main() {
  println("Half-Life " + add2(1));
}
```output
Half-Life 3
```

>>>>>

<<<<<

We can leave off the `int` return type, and it will be inferred from what type we give to the `ret`.

/////

```Vale
fn add2(x Int) {
  ret x + 2;
}
```

>>>>>

<<<<<

If it's only one line, we can leave off the `ret` and the semicolon.

/////

```Vale
fn add2(x Int) { x + 2 }
```

>>>>>

<<<<<

We can also make a *lambda*, a function inside another one. [# See the Tuples section below for an example of how lambdas are super useful.]

/////

```Vale
fn main() {
  add2 = (x Int){ x + 2 };
  println("Half-Life " + add2(1));
}
```

>>>>>

<<<<<

We can leave the type off of a lambda's parameter, to make it shorter. [#  Taking out the parameter's type makes this a "generic" lambda. See generics for more.]

/////

```Vale
fn main() {
  add2 = (x){ x + 2 };
  println("Half-Life " + add2(1));
}
```

>>>>>

<<<<<

We can shorten lambdas with the *almighty underscore*, which declares and immediately uses an implicit parameter.

/////

```Vale
fn main() {
  add2 = { _ + 2 };
  println("Half-Life " + add2(1));
}
```

>>>>>

<<<<<

In Vale, functions and methods are the same thing, [#ufcs] so these two calls are exactly equivalent.

/////

```Vale
fn main() {
  s = "Hail Hydra!".split(" ");
  s = split("Hail Hydra!", " ");
}
```

>>>>>


<notes>
#ufcs: This is known as Universal Function Call Syntax. This makes method chaining nicer, for example

`a.f(3).g(true).h("Yendor")`

as opposed to

`h(g(f(a, 3), true), "Yendor")`.
</notes>


# Tuples

<<<<<

A tuple is a simple struct, whose members are named 0, 1, 2, etc.

We can make a tuple in Vale with square brackets (like `[5, true, "V"]`), and can access them with either a dot (like `arr.0`) or square brackets (like `arr[1 + 1]`).

/////

```Vale
fn main() {
  arr = [5, true, "V"];
  println("Babylon " + arr.0);
  println("Saturn " + arr[1 + 1]); «variantindexing»
}
```output
Babylon 5
Saturn V
```

>>>>>

<<<<<

We can also make a tuple by multiplying a constant integer [#  A "constant integer" is an integer known at compile time.] with a function.

The integer determines how many elements will be in the tuple. The function takes the index, and returns the value that should be at that index.

/////

```Vale
fn add2(x Int) { x + 2 }
fn main() {
  arr = 3 * add2; «arrtype»
  println(arr);
}
```output
[2, 3, 4]
```

>>>>>

<<<<<

This is often used with lambdas.

/////

```Vale
fn main() {
  arr = 3 * {_ + 2};
  println(arr);
}
```output
[2, 3, 4]
```

>>>>>


<notes>
#variantindexing: Most language can't index into tuples, but Vale will make it possible with variant indexing. Indexing this struct gives a variant `(int|bool|str)`, with a `+` function that calls the appropriate actual `+` depending on the run-time type (`int` vs `bool` vs `str`).


#arrtype: The type of `arr` is `[3 * Int]`.
</notes>
