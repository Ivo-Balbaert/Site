---
title: Generational Malloc
subtitle: For speed and simplicity!
author: Evan Ovadia
date: Nov 24 2020
path: blog/generational-malloc
namespace: c-blog m-annotated
---


Vale's *hybrid-generational memory* is a new ground-breaking memory model that combines all the best parts of existing memory strategies: it's as easy as garbage collection, as deterministic as reference counting, and as fast as borrow checking. [#resilient]


*Generational malloc* is the keystone of the entire approach, the lynchpin that makes it all work. Keep reading to learn how it works!


Note that this is *still in development*. We have some very promising early results, so we're sharing the idea to show you where Vale is headed. If you want to be part of this and bring this into the world, come [join us](/contribute) and help make it happen!


# Generation Number: The Sacred Integer


Generational malloc is like regular malloc, except at the top of every allocation is a *generation number*, which tracks how many objects have previously been at this memory location.

One could also think of it as describing "I am the *n*th inhabitant of this memory location".

Freeing an object will increment its generation number. Nobody else ever modifies it.


Later on, we use this number to see if a particular object is still alive, explained further below.


<notes>
#resilient: Vale has three release modes:

 * Resilient mode, which is fast and memory safe; it will halt the program when we try to dereference a freed object.
 * Assist mode, for development, to detect potential problems even earlier.
 * Unsafe mode, which turns off all safety.

Resilient mode uses hybrid-generational memory.
</notes>


# References: More than just pointers!


In Vale, a reference has two things:

 * A pointer to the object.
 * A "target generation" integer.

When we create a reference to an object, we get its allocation's generation number, and include it in the reference.


<notes/>


## Dereferencing


When we dereference a reference, we do a "liveness check" to see whether the allocation's generation number still matches our reference's target generation. [#genind]

It's as if the reference is saying:

<div style="margin-left: 16px;">
*"Hello! I'm looking for the 11th inhabitant of this house, are they still around?"*
</div>

and the person who opens the door says:

<div style="margin-left: 16px;">
*"No, sorry, I am the 12th inhabitant of this house, the 11th inhabitant is no more."*
</div>

or instead:

<div style="margin-left: 16px;">
*"Yes! That is me. Which of my fields would you like to access?"*
</div>


<notes>
#genind: This is similar to the "generational indices" technique from C++ and Rust, but applied to the entire world instead of just a specific vector.
</notes>


# Speed


Generational malloc is only the first step towards hybrid-generational memory, but we decided to run some early experiments to see how it compares to existing memory models.

For this experiment, we benchmarked three flavors of Vale:

 * *Unsafe*, with no memory safety, the equivalent of C++ (minus caveats, see below!)
 * *RC*, where we use naive reference counting for all our objects.
 * *GM*, which uses Generational Malloc.


<table class="comparison">
  <thead>
    <tr>
      <th>Mode</th>
      <th>Speed&nbsp;(seconds)</th>
      <th>Overhead Compared to Unsafe (seconds)</th>
      <th>Overhead Compared to Unsafe (%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th class="na">Unsafe</th>
      <td class="na">43.82&nbsp;seconds</td>
      <td class="na">n/a</td>
      <td class="na">n/a</td>
    </tr>
    <tr>
      <th class="na">RC</th>
      <td class="bad">54.90&nbsp;seconds</td>
      <td class="bad">+11.08&nbsp;seconds</td>
      <td class="bad">+25.29%</td>
    </tr>
    <tr>
      <th class="na">GM</th>
      <td class="good">48.57&nbsp;seconds</td>
      <td class="good">+4.75&nbsp;seconds</td>
      <td class="good">+10.84%</td>
    </tr>
  </tbody>
</table>


Generational Malloc adds only 10.84% to the run time of a program, *less than half the cost of reference counting!* These are very promising results, and suggest that full hybrid-generational memory could be incredibly fast.


Try it out! In the Vale release, you can find a benchmark folder with scripts to run the benchmarks. You can find the source code for the various approaches [here](https://github.com/ValeLang/Vale/tree/master/Midas/src/c-compiler/region) (feel free to swing by the [discord server](https://discord.gg/SNB8yGH) and we can point you to the right files).


*Note these caveats!* To isolate the difference between generational malloc and the other approaches, for each of the flavors, we:

 * Only allocate objects on the heap, except for primitives. Future versions will add stack allocations, and a "local generation table" to store generation numbers for them.
 * Instead of using free(), kept allocations in free-lists, one for each size class. Future versions will integrate generational malloc into jemalloc or mimalloc directly.

Once we address these limitations, we can get more meaningful benchmarks against the other approaches.


<notes/>


# What's Next?


Generational malloc is only the first step, and it already beats reference counting.

When hybrid-generational memory is fully realized, we expect it will be as fast as Rust, and almost as fast as C++.

We're excited about this, because it gives us raw speed with zero unsafety, while keeping the language easy to learn and use.

See [Hybrid-Generational Memory](/blog/hybrid-generational-memory) to learn more, and feel free to swing by the [discord server](https://discord.gg/SNB8yGH) with any questions or ideas!


<notes/>
