---
title: Surprising Weak-ref Implementations: Vale, Swift, ObjC, Rust, C#
subtitle: What even is a weak reference?
author: Evan Ovadia
date: Dec 23
realm: blog
path: blog/hybrid-generational-memory
layout: annotated
namespace: c-blog m-annotated
---






in between the unowned pointer,  which is similar to a raw pointer in C & C plus plus.  this pointer is conceptually week with an assertion that it is still alive when we use it. valgrind does this for us. we might support this kind of reference in vale, but only to weakable objects, so people are aware of the cost. 

Backreferences

ObjC

I have to explain objective C first because it's just downright retarded. It maintains a global mutex-guarded hashmap of every weak pointer that is pointing at any object.  whenever we delete an object we look through that hashmap and  null out anyone pointing at us. https://stackoverflow.com/a/42847825 https://stackoverflow.com/a/23689503 this is extremely expensive. however there is one benefit.  there is zero cost to check whether a weak reference is pointing at something or nothing.
I'm not really opposed to having a global map either we basically do that in Vail but much better.  I'm also not opposed to having a vector of back references,  we almost did that in Vail.  the problem here was that it had to be Atomic and shared across threads which slowed everything down.  if Swift had the kind of memory isolation that rust and Veil had this would be an amazing approach. 


We considered having weakable objects have a vector of back references,  so we could have zero cost like Swift does.  it wouldn't be that expensive for us either,  because ours would not have to be atomic and removing and adding would be constant time  with our special set trick.  we might even be able to use simd  to parallelize setting all these things to null.  in the end we decided not to,  because all of these vectors would grow to Infinity, And use a lot of space.  perhaps if we cashed them and had some sort of smart system for shrinking them back again,  this could be a viable strategy. 



Ref-counting

WRC Outside: Rust Rc

C++'s shared_ptr works like this.

C plus plus weak pointers are interesting.  the STL has built-in shared pointer and weak pointer but they have to be a Tomic so they are very slow.  on top of that they force you to use shared-ownership which means you lose a lot of Raii benefits,  see the next steps for single ownership.  shared pointer uses a control block which is a separately allocated chunk of memory which has a weak counter a shared counter and a pointer to the object.  as long as there's any weak pointers active,  the control block will stay alive. 

the drawback of rust and C plus plus approach is that  it takes two indirections to get to the object.

rust has RC Which is not an atomic so it's very fast. It uses a similar control block pattern that like cplusplus.


WRC Inside: Swift

Swift has another approach if it's not doing interop with objective-c. https://mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html  the object would have a weak pointer count,  and we wouldn't stay allocate the object until all the week pointers went away.  this means that we can destroy an object but it won't be the allocated until all the weak pointers go away.  this would use a lot of memory, but it would be very fast. There's also a problem related to threading here; we couldn't have it live inside the object because then we might be Reaching Across threads to check  whether it's alive or not. But if we have the WRC separate from the object then we can send the object to another thread and keep our WRC here. 

This is not a zero cost abstraction,  every object has  this counter.

 these are especially important since we have to because we need to use them to break Cycles.






Inside: Python

https://dev.nextthought.com/blog/2018/05/python-weakref-cython-slots.html

"This example was written in CPython, which uses a reference counting garbage collection system. In this system, weak references are (usually!) cleared immediately after the last strong reference goes away. In other implementations like PyPy or Jython that use a different garbage collection strategy, the reference may not be cleared until some time later. Even in CPython, reference cycles may delay the clearing. Don't depend on references being cleared immediately!"

You can attach Call backs which is kind of cool,  but it does cause a lot of weird effects, see https://hg.python.org/cpython/file/4e687d53b645/Modules/gc_weakref.txt.

DO NOT USE. deterministic until you fuck up and make a cycle, or switch to gc.


GC


C#

 c# weak pointers suck.  they're non-deterministic and you basically never want to use them ever,  because non determinism will creep into your program and you'll get very difficult bugs.  this includes languages like Java and kotlin.

 for this reason we never use finalize in C#.

Single Ownership

Dispose

Java is similar so far. Though, in Java, we often mimic weak pointers in C# with an alive Boolean,  and we manually check whether something is alive in any method on the object.

C# has a much better way of doing that. its dispose method there is a bit that will keep track of whether the object is still alive and then  CLR checks if we are accessing a disposed object.

https://docs.microsoft.com/en-us/dotnet/api/system.objectdisposedexception?view=netcore-3.1

 this is further proof that even in garbage collected languages we could benefit from single ownership.  see the next steps for raii for more on this.

Similar to an unowned pointer. 

In fact you can make a week pointer out of this by trying to call tostring and seeing if it throws an exception. 


Rust Generational Indices


Rust also has a vector of generational indices approach where the generational index kind of serves as a weak pointer. this has a very large overhead about twice the size,  and we have to have a generation in the object and in the reference.

 if rust uses a vec of boxes,  we use up less space but there is an extra indirection.

These are especially important in Rust because in Rust you can only have mutable aliasing if you use indices like this.

 cplusplus can also use a vector like this,  and suffers the same costs.



 Vale

 these are especially important in Vail because the only alternative is constraint references which could  be annoying.

 Vail has a interesting approach.  any object that can have a weak pointer pointing at it will be marked as weakable. if it is marked as weakable,  then it has an index at the top of the object. the index points to a place in the thread-local WRC table. The WRC has one bit to represent whether the object is still alive and it also has the counts of weak pointers pointing at the object.  when the object is dead and there are no more weak pointers we recycle the WRC for someone else.  every reference is a fat pointer,  of the WRC and the pointer to the actual object.  this is much better than having a control block that has the pointer because we can fetch something from the object in parallel as checking the live bit in the WRC. Another nice thing about this approach is that the strong count can be a 32-bit integer and the week index can also be a 32-bit integer. 




There is another approach which might be even faster see other article for more.

All of this is very important because resilient mode makes all constraint references into week references.  the nice thing is that the branch prediction is perfect because we assume it exists when we use it. 

We have a weakable key word to make this a zero cost abstraction. Otherwise there's no way to know when to set the alive bit to false. Also it's important to know that this object could have some consequences at a distance. This is my main gripe with having weak references so often come along with shared references. 

If we wanted to we could just look up an object in the week table by its address, then we wouldn't need the weakable keyword. But then we would have a global table and also a hashmap into that table.  it's doable,  but a little bit annoying. 

